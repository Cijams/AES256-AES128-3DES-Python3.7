import hashlib
import hmac
import Crypto
import Crypto.Cipher.AES
import Crypto.Util.Padding
import secrets
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES
from binascii import hexlify
from binascii import unhexlify
from pyDes import *
import pickle

#
#   Christopher Ijams 2019
#
#   CryptoManager.py : Encryption implementation for files
#
# ===========================================================================
#
#    TO USE: Ensure message to be encrypted is local to CryptoManager.py
#  as "plaintext.txt". Run Encryption. For decryption, program will detect
#  what algorithm was used to encrypt with. If it is AES128, AES256, or 3DES
#  it will attempt to decrypted it. Metadata for encryption serialized with pickle
#  and stored as stored as keys.pkl locally.
#
# ===========================================================================
#
#    This program demonstrates a round-trip encryption/decryption
#  of 3DES, AES128 and AES256, to and from a text file.
#
#    Initial creation of a master key is done using PBKDF#2.
#  User is allowed to select either sha256 or sha512. 100,000 iterations and a long
#  password were chosen to prevent cracking.
#
#    Both the encryption key and hmac key are derived from the master key using PBKDF#2
#  and 1 iteration. Salt values are dynamically created using proven cryptographic libraries.
#
#    Encryption algorithms are implemented using CBC chaining mode. IV's are randomly generated
#  and one block in length, adjusting size to the chosen algorithm.
#
#    Python was chosen due to strong cryptographic support via libraries, and intuitive data
#  conversion.


def generate_master_key(algorithm_choice):
    """Creation of master key using PBKDF#2 hashed with either SHA256 or SHA512.
    Salt is a randomly generated 16 characters in hex format.

    Args:
        algorithm_choice (integer):
            An integer who's value determines which algorithm is
            going to be used.

    Return:
        key (byte):
            The generated master key to be used for encryption and
            hashing derivation
    """
    salt = str.encode(secrets.token_hex(8))
    if algorithm_choice == 1:
        key = hashlib.pbkdf2_hmac('sha256', b'>>$$MasterPassword9000$$<<', salt, 100000)
    else:
        key = hashlib.pbkdf2_hmac('sha512', b'>>$$MasterPassword9000$$<<', salt, 100000)
    return key


def generate_encryption_key(key_length=16):
    """Derivation of encryption key using PBKDF#2
    Hashed with sha256 and randomly generated salt.

    Args:
        key_length (integer):
            Length of the key needed to be generated.
            accepts multiples of 16, expecting values
            of either 16 or 32.

    Return:
        key (byte):
            The encryption key for each algorithm.
    """
    salt = str.encode(secrets.token_hex(8))
    key = hashlib.pbkdf2_hmac('sha256', master_key, salt, 1, key_length)
    return key


def generate_hmac(key, data=b'123'):
    """Generate the HMAC.

    Args:
        data (byte):
            The cipher text to be hashed. Default data
            to prevent errors.
        key (byte):
            The derived key from the master encryption key.

    Return:
        HMAC (byte):
            The HMAC of the cipher text.
    """
    return hmac.new(key, data, hashlib.sha256).hexdigest()


def generate_hmac_key(key_length=16):
    """Derivation of HMAC key using PBKDF#2
    Hashed with SHA256 and randomly generated salt.

    Args:
        key_length (integer):
            Length of the key needed to be generated.
            accepts multiples of 16, expecting values
            of either 16 or 32.

    Return:
        key (byte):
            The HMAC key.
    """
    salt = str.encode(secrets.token_hex(8))
    key = hashlib.pbkdf2_hmac('sha256', master_key, salt, 1, key_length)
    return key


def hash_select():
    """Allows the user to be able to select between SHA126
    and SHA258 hashing algorithms.

    Args: None.

    Return:
        key (byte):
            The master encryption key.
    """
    print('Would you like to use sha256 or sha512?')
    print('1. sha256')
    print('2. sha512')
    while True:
        try:
            hash_choice = int(input())
            if hash_choice == 1:
                break
            if hash_choice == 2:
                break
            print('Enter 1 or 2.')
        except ValueError:
            print("Please enter 1 or 2")
            continue
    key = ""
    if hash_choice == 1:
        key = generate_master_key(1)
    if hash_choice == 2:
        key = generate_master_key(2)
    return key


def generate_iv(block_size=56):
    """Generated random bytes of various block size to
    be used as an IV.

    Args:
        block_size (integer):
            The size of the desired block.

    Return:
        random_bytes (byte):
            "block_size" amount of randomly generated bytes
            to be used as an injection vector.
    """
    return get_random_bytes(block_size)


def encrypt_aes128(plaintext):
    """Implementation of AES256. Key size of 126 bits with
    a block size of 126. PKCS7 padding. Encrypts using AES128
    to a file. Additionally, an HMAC is generated to verify
    data integrity.

    Args:
        plaintext (byte)
            The plain text to be encrypted.

    Return: None.
    """
    # Initial set up of encryption cipher.
    algorithm = "aes128"
    key_size = 16  # 128 bit key.
    block_size = 16
    encryption_key = generate_encryption_key(key_size)
    iv = generate_iv(block_size)
    plaintext = Crypto.Util.Padding.pad(plaintext, block_size, style='pkcs7')
    cipher = AES.new(encryption_key, AES.MODE_CBC, iv)

    # Encryption of data and generation of HMAC.
    ciphertext = cipher.encrypt(plaintext)
    local_hmac = generate_hmac(hmac_derived_key, ciphertext + iv)

    # Write encrypted data to file.
    try:
        f = open("encrypted.txt", "wb")
        f.write(hexlify(ciphertext))
    except FileNotFoundError:
        print("Can not find file!")

    # User feedback.
    print("NOW ENCRYPTING:" + algorithm)
    print("\nHMAC:\n" + local_hmac)
    print("\nEncrypted:")
    print(ciphertext)
    del ciphertext

    # Generate and serialize cipher metadata.
    local_keys = dict(int_list=[],
                      my_keys=encryption_key,
                      my_hmac=hmac_derived_key,
                      my_iv=iv,
                      my_block_size=block_size,
                      my_algorithm=algorithm,
                      my_key_size=key_size)

    pickle.dump(local_keys, open('keys.pkl', 'wb'))

    # Generate HMAC file.
    try:
        f = open("hmac.txt", "w")
        f.write(local_hmac)
    except FileNotFoundError:
        print("Can not find file!")


def encrypt_aes256(plaintext):
    """Implementation of AES256. Key size of 256 bits with
    a block size of 126. PKCS7 padding. Encrypts using AES256
    to a file. Additionally, an HMAC is generated to verify
    data integrity.

    Args:
        plaintext (byte)
            The plain text to be encrypted.

    Return: None.
    """
    # Implementation of AES128.
    # Block size of 16 with PKCS7 padding.
    # Encrypts and message using AES128 to a file,
    # and reads it back to decrypt the data.

    # Initial set up of encryption cipher.
    algorithm = "aes256"
    key_size = 32  # 256 bit key.
    block_size = 16
    encryption_key = generate_encryption_key(key_size)
    iv = generate_iv(block_size)
    plaintext = Crypto.Util.Padding.pad(plaintext, block_size, style='pkcs7')
    cipher = AES.new(encryption_key, AES.MODE_CBC, iv)

    # Encryption of data and generation of HMAC.
    ciphertext = cipher.encrypt(plaintext)
    local_hmac = generate_hmac(hmac_derived_key, ciphertext+iv)

    # Write encrypted data to file.
    try:
        f = open("encrypted.txt", "wb")
        f.write(hexlify(ciphertext))
    except FileNotFoundError:
        print("Can not find file!")

    # User feedback.
    print("NOW ENCRYPTING:" + algorithm)
    print("\nHMAC:\n" + local_hmac)
    print("\nEncrypted:")
    print(ciphertext)
    del ciphertext

    # Generate and serialize cipher metadata.
    local_keys = dict(int_list=[],
                      my_keys=encryption_key,
                      my_hmac=hmac_derived_key,
                      my_iv=iv,
                      my_block_size=block_size,
                      my_algorithm=algorithm,
                      my_key_size=key_size)

    pickle.dump(local_keys, open('keys.pkl', 'wb'))

    # Generate HMAC file.
    try:
        f = open("hmac.txt", "w")
        f.write(local_hmac)
    except FileNotFoundError:
        print("Can not find file!")


def encrypt_3des(plaintext):
    """Implementation of 3DES. Key size of 126 bits with
    a block size of 56 bits. PKCS7 padding. Encrypts using 3DES
    to a file. Additionally, an HMAC is generated to verify
    data integrity.

    Args:
        plaintext (byte):
            The plain text to be encrypted.

    Return: None.
    """
    # Initial set up
    algorithm = "3des"
    key_size = 16
    block_size = 16
    iv = generate_iv(8)
    encryption_key = generate_encryption_key(block_size)
    print(plaintext.decode())
    plaintext = Crypto.Util.Padding.pad(plaintext, block_size, style='pkcs7')
    cipher = triple_des(encryption_key, CBC, iv, pad=None)

    # Encryption of data and generation of HMAC.
    ciphertext = cipher.encrypt(plaintext)
    local_hmac = generate_hmac(hmac_derived_key, ciphertext+iv)

    # Write encrypted data to file.
    f = open("encrypted.txt", "wb")
    f.write(hexlify(ciphertext))

    # User feedback.
    print("NOW ENCRYPTING WITH " + algorithm.upper() + ":")
    print("\nHMAC:\n" + local_hmac)
    print("\nEncrypted:")
    print(ciphertext)
    del ciphertext

    # Generate and serialize cipher metadata.
    local_keys = dict(int_list=[],
                      my_keys=encryption_key,
                      my_hmac=hmac_derived_key,
                      my_iv=iv,
                      my_block_size=block_size,
                      my_algorithm=algorithm,
                      my_key_size=key_size)

    pickle.dump(local_keys, open('keys.pkl', 'wb'))

    # Generate HMAC file.
    try:
        f = open("hmac.txt", "w")
        f.write(local_hmac)
    except FileNotFoundError:
        print("Can not find file!")


def decrypt():
    """Decrypts from a text file cipher text that has been generated
    using algorithms 3DES, AES128, or AES256. Reads metadata from
    keys.pkl. Will detect algorithm used and send plaintext to
    "plaintext.txt".

    Args: None

    Return: None
    """
    # Initialize variables
    algorithm = "Unknown Algorithm"
    local_recovered_hmac_key = ""
    encryption_key = ""
    iv = ""
    block_size = ""

    # Unpack the data and ensure format is correct.
    try:
        enc_meta = pickle.load(open('keys.pkl', 'rb'))
        encryption_key = enc_meta['my_keys']
        local_recovered_hmac_key = enc_meta['my_hmac']
        iv = enc_meta['my_iv']
        block_size = enc_meta['my_block_size']
        algorithm = enc_meta['my_algorithm']
    except (FileNotFoundError, RuntimeError):
        print("File format is incorrect. Encrypt the data using this program.")

    # Ensure it is a registered algorithm.
    if algorithm != "aes128" and algorithm != "aes256" and algorithm != "3des":
        print("Error trying to decrypt " + algorithm)
        sys.exit(0)

    # Opening file and reading ciphertext.
    print("NOW DECRYPTING WITH " + algorithm.upper() + ":")
    ciphertext = "Failed to load."
    try:
        f = open("encrypted.txt", "br")
        ciphertext = f.read()
    except FileNotFoundError:
        print("Can not find file!")

    # Generating HMAC
    local_hmac = generate_hmac(local_recovered_hmac_key, unhexlify(ciphertext)+iv)
    print("\nGenerated HMAC:")
    print(local_hmac)

    # Reading HMAC generated at encryption time.
    test_hmac = "Failed to load."
    try:
        f = open("hmac.txt", "r")
        test_hmac = f.read()

    except FileNotFoundError:
        print("Can not find file!")

    print("\nRegistered HMAC:")
    print(test_hmac)

    # Ensure match
    if test_hmac != local_hmac:
        print("\nCORRUPTED DATA: Alterations have been made!")
        sys.exit(0)
    else:
        print("\nMATCH")

    # Choose decryption algorithm.
    if algorithm == "aes128" or algorithm == "aes256":
        decipher = AES.new(encryption_key, AES.MODE_CBC, iv)
    else:
        decipher = triple_des(encryption_key, CBC, iv, pad=None)

    # Decrypt and decode.
    plaintext = decipher.decrypt(unhexlify(ciphertext))
    plaintext = Crypto.Util.Padding.unpad(plaintext, block_size, style='pkcs7')
    print("\nDecrypted:")
    try:
        f = open("plaintext.txt", "w")
        f.write(plaintext.decode())
    except FileNotFoundError:
        print("Can not find file!")
    print(plaintext.decode())


def user_choice():
    """Get the user's decision on if they want to encrypt
    a file or decrypt one.

    Args: None

    Return:
        users_choice (integer):
            Numeric representation of the users choice.

    """
    print("\n\nWould you like to encrypt or decrypt?")
    print("1. Encrypt")
    print("2. Decrypt")
    users_choice = get_int(1)
    if users_choice == 1:
        return 1
    if users_choice == 2:
        return 2


def get_int(self=1):
    """Safely retrieve a numeric representation of
    a users choice to logic processing.

    Args:
        self (integer):
            Control flow for the number of decisions needed.

    Return:
        users_choice (integer):
            Numeric representation of the users choice.
    """
    while True:
        if self == 1:
            try:
                users_choice = int(input())
                if users_choice == 1 or users_choice == 2:
                    break
                print('Enter 1 or 2')
            except ValueError:
                print('Enter 1 or 2')
                continue
        if self == 2:
            try:
                users_choice = int(input())
                if users_choice == users_choice\
                        or users_choice == 2 or users_choice == 3:
                    break
                print('Enter 1, 2 or 3')
            except ValueError:
                print('Enter 1, 2 or 3')
                continue
    return users_choice


# Start
choice = user_choice()

#  Encryption
if choice == 1:
    try:
        unencrypted_text = (open('plaintext.txt', 'rb'))
        unencrypted_text = unencrypted_text.read()
        print()
        print("This is the plaintext to be encrypted:")
        print(unencrypted_text.decode())
        print()
    except FileNotFoundError:
        print("Ensure the text to be encrypted is in the local directory as \"plaintext.txt\"")
        sys.exit(0)
    master_key = hash_select()
    hmac_derived_key = generate_hmac_key()

    print("Please select which algorithm you would like to use:")
    print("1. 3des")
    print("2. aes128")
    print("3. aes256")
    print()
    alg = get_int(2)
    if alg == 1:
        encrypt_3des(unencrypted_text)
    if alg == 2:
        encrypt_aes128(unencrypted_text)
    if alg == 3:
        encrypt_aes256(unencrypted_text)

# Decryption
if choice == 2:
    decrypt()
